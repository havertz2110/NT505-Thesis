{
  "batch_info": {
    "processed_at": "2025-10-21T08:02:52.113038",
    "nested_strategy": "mark_nested"
  },
  "statistics": {
    "total_files": 2,
    "processed_files": 2,
    "failed_files": 0,
    "total_functions": 9,
    "total_statements": 0,
    "total_tokens": 1332
  },
  "vocabulary": {
    "<PAD>": 1,
    "<UNK>": 2,
    "<START>": 3,
    "<END>": 4,
    "#": 5,
    "VAR": 6,
    "\"STRING_LITERAL\"": 7,
    "MACRO_VAR": 8,
    "TYPE_VAR": 9,
    "else": 10,
    "<": 11,
    ".": 12,
    ">": 13,
    "(": 14,
    ",": 15,
    ")": 16,
    "/": 17,
    "socket": 18,
    "-": 19,
    "1": 20,
    "int": 21,
    "NUM_LITERAL": 22,
    "fopen": 23,
    "void": 24,
    "char": 25,
    "*": 26,
    ";": 27,
    "[": 28,
    "]": 29,
    "=": 30,
    "0": 31,
    "struct": 32,
    "do": 33,
    "if": 34,
    "&": 35,
    "!=": 36,
    "break": 37,
    "==": 38,
    "memset": 39,
    "connect": 40,
    "recv": 41,
    "+": 42,
    "||": 43,
    "'": 44,
    "\\": 45,
    "while": 46,
    "NULL": 47,
    "fclose": 48,
    "static": 49,
    "strcat": 50,
    "return": 51
  },
  "vocabulary_size": 51,
  "files": [
    {
      "file_path": "/mnt/d/GitHub/NT505-Thesis/slicing/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01.cpp",
      "file_name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01.cpp",
      "processed_at": "2025-10-21T08:02:52.107656",
      "statistics": {
        "function_count": 4,
        "statement_count": 0,
        "token_count": 628,
        "nested_function_count": 0,
        "vulnerable_function_count": 3
      },
      "sliced_data": {
        "level": "L0",
        "type": "PROGRAM",
        "name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01.cpp",
        "full_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01\n{\n\n#ifndef OMITBAD\n\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n\n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITGOOD\n\n\nstatic void goodG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif \n\n} \n\n\n\n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}\n\n#endif\n",
        "start_line": 1,
        "end_line": 199,
        "line_count": 199,
        "metadata": {
          "source_path": "/mnt/d/GitHub/NT505-Thesis/slicing/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01.cpp",
          "includes": [
            "#include \"std_testcase.h\"",
            "#include <wchar.h>",
            "#include <winsock2.h>",
            "#include <windows.h>",
            "#include <direct.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>"
          ],
          "global_variables": [
            {
              "name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01",
              "type": "using namespace",
              "line": 180
            }
          ],
          "total_lines": 199
        },
        "modules": [
          {
            "level": "L1",
            "type": "MODULE",
            "name": "sockaddr_in",
            "full_code": "        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n\n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }",
            "start_line": 69,
            "end_line": 117,
            "line_count": 49,
            "metadata": {
              "type": "struct_module"
            }
          },
          {
            "level": "L1",
            "type": "MODULE",
            "name": "GLOBAL_SCOPE",
            "full_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01\n{\n\n#ifndef OMITBAD\n\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n\n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITGOOD\n\n\nstatic void goodG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif \n\n} \n\n\n\n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}\n\n#endif",
            "start_line": 1,
            "end_line": 199,
            "line_count": 199,
            "metadata": {
              "type": "global_functions"
            },
            "functions": [
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "bad",
                "full_code": "void bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            \n\n            \n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            \n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            \n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}",
                "start_line": 58,
                "end_line": 139,
                "line_count": 82,
                "metadata": {
                  "return_type": "void",
                  "parameters": [],
                  "signature": "void bad()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                },
                "blocks": [
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }",
                    "start_line": 76,
                    "end_line": 79,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "WSAStartup(MAKEWORD(2,2",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "            wsaDataInit = 1;\n#endif\n            \n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;",
                    "start_line": 80,
                    "end_line": 86,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 82,
                      "annotation": "/* POTENTIAL FLAW: Read data using a connect socket */",
                      "vulnerable_line": "connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);",
                      "focus_line_number": 83,
                      "detected_by": "comment_potential_flaw"
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }",
                    "start_line": 92,
                    "end_line": 95,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "connect(connectSocket, (struct sockaddr*",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }",
                    "start_line": 100,
                    "end_line": 103,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "recvResult == SOCKET_ERROR || recvResult == 0",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "            if (replace)\n            {\n                *replace = '\\0';\n            }",
                    "start_line": 108,
                    "end_line": 111,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "replace",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "            if (replace)\n            {\n                *replace = '\\0';\n            }",
                    "start_line": 113,
                    "end_line": 116,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "replace",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "while_block",
                    "full_code": "        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }",
                    "start_line": 118,
                    "end_line": 122,
                    "line_count": 5,
                    "metadata": {
                      "block_type": "loop",
                      "loop_type": "while",
                      "condition": "0"
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "        if (wsaDataInit)\n        {\n            WSACleanup();\n        }",
                    "start_line": 124,
                    "end_line": 127,
                    "line_count": 4,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "wsaDataInit",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);",
                    "start_line": 130,
                    "end_line": 136,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 132,
                      "annotation": "/* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */",
                      "vulnerable_line": "pFile = FOPEN(data, \"wb+\");",
                      "focus_line_number": 133,
                      "detected_by": "comment_potential_flaw"
                    }
                  }
                ]
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "goodG2B",
                "full_code": "static void goodG2B()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    \n    strcat(data, \"file.txt\");\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}",
                "start_line": 146,
                "end_line": 162,
                "line_count": 17,
                "metadata": {
                  "return_type": "static void",
                  "parameters": [],
                  "signature": "static void goodG2B()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                },
                "blocks": [
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);",
                    "start_line": 153,
                    "end_line": 159,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 155,
                      "annotation": "/* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */",
                      "vulnerable_line": "pFile = FOPEN(data, \"wb+\");",
                      "focus_line_number": 156,
                      "detected_by": "comment_potential_flaw"
                    }
                  }
                ]
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "good",
                "full_code": "void good()\n{\n    goodG2B();\n}",
                "start_line": 164,
                "end_line": 167,
                "line_count": 4,
                "metadata": {
                  "return_type": "void",
                  "parameters": [],
                  "signature": "void good()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                }
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "main",
                "full_code": "int main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}",
                "start_line": 182,
                "end_line": 197,
                "line_count": 16,
                "metadata": {
                  "return_type": "int",
                  "parameters": [
                    {
                      "name": "argc",
                      "type": "int"
                    },
                    {
                      "name": "argv",
                      "type": "char *"
                    }
                  ],
                  "signature": "int main(int argc, char * argv[])",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                }
              }
            ]
          }
        ]
      }
    },
    {
      "file_path": "/mnt/d/GitHub/NT505-Thesis/slicing/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02.cpp",
      "file_name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02.cpp",
      "processed_at": "2025-10-21T08:02:52.113013",
      "statistics": {
        "function_count": 5,
        "statement_count": 0,
        "token_count": 704,
        "nested_function_count": 0,
        "vulnerable_function_count": 3
      },
      "sliced_data": {
        "level": "L0",
        "type": "PROGRAM",
        "name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02.cpp",
        "full_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02\n{\n\n#ifndef OMITBAD\n\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n\n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITGOOD\n\n\nstatic void goodG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void goodG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif \n\n} \n\n\n\n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}\n\n#endif\n",
        "start_line": 1,
        "end_line": 233,
        "line_count": 233,
        "metadata": {
          "source_path": "/mnt/d/GitHub/NT505-Thesis/slicing/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02.cpp",
          "includes": [
            "#include \"std_testcase.h\"",
            "#include <wchar.h>",
            "#include <winsock2.h>",
            "#include <windows.h>",
            "#include <direct.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>"
          ],
          "global_variables": [
            {
              "name": "CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02",
              "type": "using namespace",
              "line": 214
            }
          ],
          "total_lines": 233
        },
        "modules": [
          {
            "level": "L1",
            "type": "MODULE",
            "name": "sockaddr_in",
            "full_code": "            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n\n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }",
            "start_line": 71,
            "end_line": 119,
            "line_count": 49,
            "metadata": {
              "type": "struct_module"
            }
          },
          {
            "level": "L1",
            "type": "MODULE",
            "name": "GLOBAL_SCOPE",
            "full_code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"std_testcase.h\"\n\n#ifdef _WIN32\n#define BASEPATH \"c:\\\\temp\\\\\"\n#else\n#include <wchar.h>\n#define BASEPATH \"/tmp/\"\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") \n#define CLOSE_SOCKET closesocket\n#else \n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define IP_ADDRESS \"127.0.0.1\"\n\n#ifdef _WIN32\n#define FOPEN fopen\n#else\n#define FOPEN fopen\n#endif\n\nnamespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02\n{\n\n#ifndef OMITBAD\n\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n\n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif \n\n#ifndef OMITGOOD\n\n\nstatic void goodG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n\nstatic void goodG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif \n\n} \n\n\n\n\n\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02; \n\nint main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}\n\n#endif",
            "start_line": 1,
            "end_line": 233,
            "line_count": 233,
            "metadata": {
              "type": "global_functions"
            },
            "functions": [
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "bad",
                "full_code": "void bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n\n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}",
                "start_line": 58,
                "end_line": 142,
                "line_count": 85,
                "metadata": {
                  "return_type": "void",
                  "parameters": [],
                  "signature": "void bad()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                },
                "blocks": [
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                \n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                \n\n                \n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                \n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                \n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }",
                    "start_line": 63,
                    "end_line": 132,
                    "line_count": 70,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "1",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);",
                    "start_line": 133,
                    "end_line": 139,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 135,
                      "annotation": "/* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */",
                      "vulnerable_line": "pFile = FOPEN(data, \"wb+\");",
                      "focus_line_number": 136,
                      "detected_by": "comment_potential_flaw"
                    }
                  }
                ]
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "goodG2B1",
                "full_code": "static void goodG2B1()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}",
                "start_line": 149,
                "end_line": 173,
                "line_count": 25,
                "metadata": {
                  "return_type": "static void",
                  "parameters": [],
                  "signature": "static void goodG2B1()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                },
                "blocks": [
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "    if(0)\n    {\n        \n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        \n        strcat(data, \"file.txt\");\n    }",
                    "start_line": 154,
                    "end_line": 163,
                    "line_count": 10,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "0",
                      "has_else": true
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);",
                    "start_line": 164,
                    "end_line": 170,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 166,
                      "annotation": "/* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */",
                      "vulnerable_line": "pFile = FOPEN(data, \"wb+\");",
                      "focus_line_number": 167,
                      "detected_by": "comment_potential_flaw"
                    }
                  }
                ]
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "goodG2B2",
                "full_code": "static void goodG2B2()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(1)\n    {\n        \n        strcat(data, \"file.txt\");\n    }\n    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}",
                "start_line": 176,
                "end_line": 195,
                "line_count": 20,
                "metadata": {
                  "return_type": "static void",
                  "parameters": [],
                  "signature": "static void goodG2B2()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                },
                "blocks": [
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "if_block",
                    "full_code": "    if(1)\n    {\n        \n        strcat(data, \"file.txt\");\n    }",
                    "start_line": 181,
                    "end_line": 185,
                    "line_count": 5,
                    "metadata": {
                      "block_type": "conditional",
                      "condition": "1",
                      "has_else": false
                    }
                  },
                  {
                    "level": "L3",
                    "type": "STATEMENT_BLOCK",
                    "name": "vulnerable_context",
                    "full_code": "    {\n        FILE *pFile = NULL;\n        \n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);",
                    "start_line": 186,
                    "end_line": 192,
                    "line_count": 7,
                    "metadata": {
                      "block_type": "potential_flaw_context",
                      "annotation_line_number": 188,
                      "annotation": "/* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */",
                      "vulnerable_line": "pFile = FOPEN(data, \"wb+\");",
                      "focus_line_number": 189,
                      "detected_by": "comment_potential_flaw"
                    }
                  }
                ]
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "good",
                "full_code": "void good()\n{\n    goodG2B1();\n    goodG2B2();\n}",
                "start_line": 197,
                "end_line": 201,
                "line_count": 5,
                "metadata": {
                  "return_type": "void",
                  "parameters": [],
                  "signature": "void good()",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                }
              },
              {
                "level": "L2",
                "type": "FUNCTION",
                "name": "main",
                "full_code": "int main(int argc, char * argv[])\n{\n    \n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    good();\n    printLine(\"Finished good()\");\n#endif \n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    bad();\n    printLine(\"Finished bad()\");\n#endif \n    return 0;\n}",
                "start_line": 216,
                "end_line": 231,
                "line_count": 16,
                "metadata": {
                  "return_type": "int",
                  "parameters": [
                    {
                      "name": "argc",
                      "type": "int"
                    },
                    {
                      "name": "argv",
                      "type": "char *"
                    }
                  ],
                  "signature": "int main(int argc, char * argv[])",
                  "is_library": false,
                  "is_nested": false,
                  "function_scope": "top_level"
                }
              }
            ]
          }
        ]
      }
    }
  ]
}